# [대충 만든 자판(연습 문제)](https://school.programmers.co.kr/learn/courses/30/lessons/160586)

> 문제 설명

휴대폰의 자판은 컴퓨터 키보드 자판과는 다르게 하나의 키에 여러 개의 문자가 할당될 수 있습니다. 키 하나에 여러 문자가 할당된 경우, 동일한 키를 연속해서 빠르게 누르면 할당된 순서대로 문자가 바뀝니다.

예를 들어, 1번 키에 "A", "B", "C" 순서대로 문자가 할당되어 있다면 1번 키를 한 번 누르면 "A", 두 번 누르면 "B", 세 번 누르면 "C"가 되는 식입니다.

같은 규칙을 적용해 아무렇게나 만든 휴대폰 자판이 있습니다. 이 휴대폰 자판은 키의 개수가 1개부터 최대 100개까지 있을 수 있으며, 특정 키를 눌렀을 때 입력되는 문자들도 무작위로 배열되어 있습니다. 또, 같은 문자가 자판 전체에 여러 번 할당된 경우도 있고, 키 하나에 같은 문자가 여러 번 할당된 경우도 있습니다. 심지어 아예 할당되지 않은 경우도 있습니다. 따라서 몇몇 문자열은 작성할 수 없을 수도 있습니다.

이 휴대폰 자판을 이용해 특정 문자열을 작성할 때, 키를 최소 몇 번 눌러야 그 문자열을 작성할 수 있는지 알아보고자 합니다.

1번 키부터 차례대로 할당된 문자들이 순서대로 담긴 문자열배열 `keymap`과 입력하려는 문자열들이 담긴 문자열 배열 `targets`가 주어질 때, 각 문자열을 작성하기 위해 키를 최소 몇 번씩 눌러야 하는지 순서대로 배열에 담아 return 하는 solution 함수를 완성해 주세요.

단, 목표 문자열을 작성할 수 없을 때는 -1을 저장합니다.

---

### 제한사항

- 1 ≤ `keymap`의 길이 ≤ 100
    - 1 ≤ `keymap`의 원소의 길이 ≤ 100
    - `keymap[i]`는 i + 1번 키를 눌렀을 때 순서대로 바뀌는 문자를 의미합니다.
        - 예를 들어 `keymap[0]` = "ABACD" 인 경우 1번 키를 한 번 누르면 A, 두 번 누르면 B, 세 번 누르면 A 가 됩니다.
    - `keymap`의 원소의 길이는 서로 다를 수 있습니다.
    - `keymap`의 원소는 알파벳 대문자로만 이루어져 있습니다.
- 1 ≤ `targets`의 길이 ≤ 100
    - 1 ≤ `targets`의 원소의 길이 ≤ 100
    - `targets`의 원소는 알파벳 대문자로만 이루어져 있습니다.

---

### 입출력 예

| keymap | targets | result |
| --- | --- | --- |
| ["ABACD", "BCEFD"] | ["ABCD","AABB"] | [9, 4] |
| ["AA"] | ["B"] | [-1] |
| ["AGZ", "BSSS"] | ["ASA","BGZ"] | [4, 6] |

#

> 해결

```jsx
function solution(keymap, targets) {
    const answer = []
    let obj = {}

    // keys 문자열을 한 글자씩 분리하여 key 변수에 할당하고, 해당 key를 누를때 필요한 최소 횟수를 저장
    keymap.forEach(keys => keys.split("").forEach((key, index) => obj = obj[key] < index + 1  ? obj : {...obj, [key] : index + 1}))

    for (const target of targets) {
        let count = 0
        for (const key of target.split("")) {
            if (!obj[key]) {   // key가 keymap에 없으면 -1을 count에 할당하고 break
                count = -1
                break
            }
            count += obj[key]  // key가 keymap에 있으면 count(해당 key를 눌러야하는 횟수) 누적
        }
        answer.push(count)
    }

    return answer
}
```

#

> 코드 개선

```jsx
function solution(keymap, targets) {
    const indexMap = {}
    for (let i = 0; i < keymap.length; i++) {
        for (let j = 0; j < keymap[i].length; j++) {
            const char = keymap[i][j]
            indexMap[char] = Math.min(indexMap[char], j + 1) || j + 1
        }
    }
    const result = targets.map(str => {
        let count = 0
        for (let i = 0; i < str.length; i++) {
            const char = str.charAt(i)
            if (!indexMap[char]) {
                count = -1
                break
            }
            count += indexMap[char]
        }
        return count
    })
    return result
}
```

| 케이스 | 기존 코드 | 개선된 코드 | 시간 | 메모리 |
| --- | --- | --- | --- | --- |
| 테스트 1 〉 | 통과 (0.66ms, 33.7MB) | 통과 (0.32ms, 33.5MB) | ▼ 0.34ms(-51.52%) | ▼ 0.2MB(-0.59%) |
| 테스트 2 〉 | 통과 (0.43ms, 33.6MB) | 통과 (0.31ms, 33.6MB) | ▼ 0.12ms(-27.91%) | - |
| 테스트 3 〉 | 통과 (0.38ms, 33.6MB) | 통과 (0.28ms, 33.3MB) | ▼ 0.10ms(-26.32%) | ▼ 0.3MB(-0.89%) |
| 테스트 4 〉 | 통과 (0.47ms, 33.7MB) | 통과 (0.32ms, 33.5MB) | ▼ 0.15ms(-31.91%) | ▼ 0.2MB(-0.59%) |
| 테스트 5 〉 | 통과 (0.46ms, 33.6MB) | 통과 (0.30ms, 33.5MB) | ▼ 0.16ms(-34.78%) | ▼ 0.1MB(-0.30%) |
| 테스트 6 〉 | 통과 (0.65ms, 33.6MB) | 통과 (0.33ms, 33.5MB) | ▼ 0.32ms(-49.23%) | ▼ 0.1MB(-0.30%) |
| 테스트 7 〉 | 통과 (0.42ms, 33.6MB) | 통과 (0.28ms, 33.3MB) | ▼ 0.14ms(-33.33%) | ▼ 0.3MB(-0.89%) |
| 테스트 8 〉 | 통과 (0.42ms, 33.6MB) | 통과 (0.29ms, 33.5MB) | ▼ 0.13ms(-30.95%) | ▼ 0.1MB(-0.30%) |
| 테스트 9 〉 | 통과 (0.49ms, 33.6MB) | 통과 (0.28ms, 33.5MB) | ▼ 0.21ms(-42.86%) | ▼ 0.1MB(-0.30%) |
| 테스트 10 〉 | 통과 (0.43ms, 33.6MB) | 통과 (0.28ms, 33.4MB) | ▼ 0.15ms(-34.88%) | ▼ 0.2MB(-0.60%) |
| 테스트 11 〉 | 통과 (0.17ms, 33.4MB) | 통과 (0.19ms, 33.4MB) | ▲ 0.02ms(11.76%) | - |
| 테스트 12 〉 | 통과 (0.17ms, 33.5MB) | 통과 (0.09ms, 33.4MB) | ▼ 0.08ms(-47.06%) | ▼ 0.1MB(-0.30%) |
| 테스트 13 〉 | 통과 (0.11ms, 33.4MB) | 통과 (0.09ms, 33.4MB) | ▼ 0.02ms(-18.18%) | - |
| 테스트 14 〉 | 통과 (0.91ms, 33.8MB) | 통과 (0.75ms, 33.5MB) | ▼ 0.16ms(-17.58%) | ▼ 0.3MB(-0.89%) |
| 테스트 15 〉 | 통과 (0.99ms, 33.8MB) | 통과 (0.83ms, 33.6MB) | ▼ 0.16ms(-16.16%) | ▼ 0.2MB(-0.59%) |
| 테스트 16 〉 | 통과 (0.99ms, 33.8MB) | 통과 (0.82ms, 33.5MB) | ▼ 0.17ms(-17.17%) | ▼ 0.3MB(-0.89%) |
| 테스트 17 〉 | 통과 (0.98ms, 33.8MB) | 통과 (0.84ms, 33.4MB) | ▼ 0.14ms(-14.29%) | ▼ 0.4MB(-1.18%) |
| 테스트 18 〉 | 통과 (0.80ms, 33.7MB) | 통과 (0.62ms, 33.6MB) | ▼ 0.18ms(-22.50%) | ▼ 0.1MB(-0.30%) |
| 테스트 19 〉 | 통과 (0.86ms, 33.8MB) | 통과 (0.72ms, 33.4MB) | ▼ 0.14ms(-16.28%) | ▼ 0.4MB(-1.18%) |
| 테스트 20 〉 | 통과 (0.79ms, 33.8MB) | 통과 (0.64ms, 32MB) | ▼ 0.15ms(-18.99%) | ▼ 1.8MB(-5.33%) |
| 테스트 21 〉 | 통과 (0.89ms, 33.7MB) | 통과 (0.76ms, 32.2MB) | ▼ 0.13ms(-14.61%) | ▼ 1.5MB(-4.45%) |
| 테스트 22 〉 | 통과 (0.98ms, 33.8MB) | 통과 (0.83ms, 33.5MB) | ▼ 0.15ms(-15.31%) | ▼ 0.3MB(-0.89%) |
| 테스트 23 〉 | 통과 (0.93ms, 33.8MB) | 통과 (0.74ms, 33.5MB) | ▼ 0.19ms(-20.43%) | ▼ 0.3MB(-0.89%) |
